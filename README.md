# Azure Serverless Queue to Blob Application

This repository contains code for an Azure serverless application that listens to messages from an Azure Queue and stores them as JSON objects in an Azure Blob Storage container.

## Overview

This application uses terraform for configuring and conneting to the specific azure account and C# is used for the creation of function which takes the message from queue and stores it in blob

## Components

### Azure Function

An Azure Function written in C# processes messages from the Azure Queue and stores them as JSON objects in Azure Blob Storage. The function is triggered by messages in the queue using Azure SDK or Azure Functions runtime libraries.

### Azure Queue Storage

Azure Queue Storage stores messages asynchronously sent from various sources, such as applications or services, for processing by the Azure Function.

### Azure Blob Storage

Azure Blob Storage stores JSON objects generated by the Azure Function. Each message processed by the function is converted to a JSON object and stored as a blob in the specified container.

## Prerequisites

- Azure Account : an active azure account is mandetory
- Make sure VS Code and necccesary extentions in vs code are installed
- Make sure Terraform is installed and condigured 

## Steps for developing the application

### Manually (using azure UI)

#### 1. Create Azure Resources

1. **Azure Storage Account:**
   - Navigate to the Azure portal.
   - Click on "+ Create a resource" in the upper left corner.
   - Search for "Storage account" and select it from the results.
   - Click "Create".
   - Fill out the required information such as subscription, resource group, storage account name, location, and performance.
   - Click "Review + create" and then "Create" to create the storage account.

2. **Azure Queue Storage:**
   - Once the storage account is created, navigate to it.
   - In the left-hand menu, under "Blob service", click on "Queues".
   - Click on "+ Queue" to create a new queue.
   - Provide a name for the queue and leave other settings as default.
   - Click "Create" to create the queue.

3. **Azure Blob Storage:**
   - Similarly, navigate to the storage account.
   - In the left-hand menu, under "Blob service", click on "Containers".
   - Click on "+ Container" to create a new container.
   - Provide a name for the container, set the access level (e.g., private, blob, container), and click "Create".

#### 2. Create Azure Function App

1. **Azure Function App:**
   - Navigate to the Azure portal dashboard.
   - Click on "+ Create a resource" and search for "Function App".
   - Select "Function App" from the results and click "Create".
   - Fill out the required information such as subscription, resource group, function app name, runtime stack (e.g., .NET), region, and hosting plan.
   - Click "Review + create" and then "Create" to create the function app.
  
2. Below is the C# code for the Azure Function that processes messages from the Azure Queue and stores them in Azure Blob Storage as JSON files:


```bash

using System;
using System.IO;
using System.Threading.Tasks;
using Azure.Storage.Blobs;
using Microsoft.Azure.WebJobs;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;

public static class Function1
{
    [FunctionName("Function1")]
    public static async Task Run(
        [QueueTrigger("taskqueue", Connection = "AzureWebJobsStorage")] string queueItem,
        ILogger log)
    {
        log.LogInformation($"Received queue item: {queueItem}");

        try
        {
            var connectionString = Environment.GetEnvironmentVariable("AzureWebJobsStorage");
            var containerName = Environment.GetEnvironmentVariable("taskstorage");

            if (string.IsNullOrEmpty(connectionString) || string.IsNullOrEmpty(containerName))
            {
                log.LogError("Storage connection string or container name is not set in the environment variables.");
                return;
            }

            var blobServiceClient = new BlobServiceClient(connectionString);
            var blobContainerClient = blobServiceClient.GetBlobContainerClient(containerName);
            
            
            await blobContainerClient.CreateIfNotExistsAsync();

            var jsonObject = JsonConvert.DeserializeObject(queueItem);
            var jsonString = JsonConvert.SerializeObject(jsonObject, Formatting.Indented);

            var blobName = $"message-{Guid.NewGuid()}.json";
            var blobClient = blobContainerClient.GetBlobClient(blobName);

            using (var ms = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(jsonString)))
            {
                await blobClient.UploadAsync(ms, overwrite: true);
            }

            log.LogInformation($"Queue item successfully written to blob: {blobClient.Uri}");
        }
        catch (Exception ex)
        {
            log.LogError($"Error processing queue item: {ex.Message}");
            throw;
        }
    }
}
```

### Programatically (using CLI Language(TerraForm))

#### 1. Define Terraform Configuration

1. **Azure Resource Group:**
   - Create a Terraform configuration to define an Azure resource group.

2. **Azure Storage Account:**
   - Define Terraform configuration to create an Azure Storage Account.

3. **Azure Queue Storage:**
   - Create Terraform configuration to provision an Azure Queue within the Storage Account.

4. **Azure Blob Storage:**
   - Define Terraform configuration to create an Azure Blob Storage Container.

5. **Azure Function App:**
   - Configure Terraform to provision an Azure Function App that will process messages from the Queue and store them in Blob Storage.

#### 2. Deploy Terraform Configuration

1. **Initialize Terraform:**
   - Run `terraform init` to initialize Terraform in the project directory.

2. **Plan Deployment:**
   - Execute `terraform plan` to review the changes Terraform will make.

3. **Apply Deployment:**
   - Run `terraform apply` and confirm the changes to deploy the Azure resources.
   - 
4. **Deployment**
    - Deploy Azure Function Code: Deploy your C# Azure Function code to the Azure Function App created by Terraform. This can be done using various deployment methods, such as using Azure DevOps pipelines, GitHub Actions, or the Azure CLI.

### Commands

##### The commands which are used are:

1. **`terraform init`**
   - This command initializes a Terraform working directory by downloading the necessary plugins and modules defined in your configuration files (`*.tf`). It prepares your Terraform environment for further actions such as planning and applying changes.

2. **`terraform plan`**
   - The `terraform plan` command generates an execution plan based on the Terraform configuration files in your working directory. It compares the desired state (defined in your configuration) with the current state of your infrastructure and outputs the changes Terraform will make.

3. **`terraform apply`**
   - This command applies the changes described in the Terraform execution plan. It provisions, updates, or deletes resources as necessary to align the actual state with the desired state defined in your configuration files. It's important to review the execution plan (`terraform plan`) before applying changes to avoid unintended modifications to your infrastructure.

### Testing
we can test the application manually by sending the file into queue storage



